## 운영체제

<details>
<summary>Q. 운영체제란?.</summary>
<div markdown="1">


<span style="background:rgba(74, 82, 199, 0.2)">운영체제란 컴퓨터 사용자와 컴퓨터 HW 간의 인터페이스로서 동작하는 시스템 SW의 일종으로, 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공해줍니다.</span>

![](https://i.imgur.com/IO8Ei9b.png)

운영체제의 코어(핵심) 부분을 **커널(Kernel)**이라고 하는데, 일반적으로는 커널에 여러가지 기능(라이브러리, 시스템 프로그램 등등)이 추가된 상태를 통칭해서 운영체제(OS)라고 한다.

### 운영체제의 주요 목적은?

CPU, 입출력 장치, 프로세스 등 컴퓨터 시스템의 자원을 관리하여 컴퓨터 시스템이 제대로 작동하도록 합니다. 이외에도 처리능력 향상, 반환 시간 단축, 신뢰도 향상 등이 있습니다.

- 처리능력: 일정 시간 내에 시스템이 처리하는 일의 양
- 신뢰도: 시스템이 주어진 문제를 정확하게 해결하는 정도
- 반환 시간: 일정 시간 내에 시스템이 처리하는 일의 양


</div>
</details>

<details>
<summary>Q.프로세스와 스레드의 차이?</summary>
<div markdown="1">

> - 프로세스: 운영체제로부터 자원을 할당받은 작업의 단위.  
> - 스레드: 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위.

### 프로세스 
- 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당받는다.
- 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
- 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, inter-process communication)을 사용해야 한다.

  ![](https://i.imgur.com/TkHdAJQ.png)



### 스레드 
스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
- 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.
- 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
- 각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
- 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있다.

  ![](https://i.imgur.com/iBkvhWc.png)


**<font color="#00b050">한마디로 요약:</font>**
프로세스는 각각 독립된 메모리 영역을 할당받는 반면에, 스레드는 stack 만 따로 할당 받고 code,data,heap 을 공유한다는 차이점이 있습니다. 



[이해하기 좋은 글](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4)

</div>
</details>

<details>
<summary>Q.멀티 스레드와 멀티 프로세스의 차이</summary>
<div markdown="1">



![](https://i.imgur.com/tzoRBQU.png)

### 멀티 프로세스
**멀티 프로세싱이란**

하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(태스크)을 처리하도록 하는 것이다.

**<font color="#00b050">장점</font>**
여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않는다.

<font color="#ff0000">**단점**</font>
**Context Switching에서의 오버헤드**
Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 된다.

프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어, Context Switching가 발생하면 캐쉬에 있는 모든 데이터를 모두 리셋하고 <u>다시 캐쉬 정보를 불러와야 한다.</u>

**프로세스 사이의 어렵고 복잡한 통신 기법(IPC)**
프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없다.



### 멀티 스레드
**멀티 스레딩이란**
하나의 응용프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것이다.


<font color="#00b050">**장점**</font>

**시스템 자원 소모 감소 (자원의 효율성 증대)**

프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.

**시스템 처리량 증가 (처리 비용 감소)**

스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
스레드 사이의 작업량이 작아 Context Switching이 빠르다.
간단한 통신 방법으로 인한 프로그램 응답 시간 단축

스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 <u>통신의 부담이 적다.</u>

**<font color="#ff0000">단점</font>**
- 주의 깊은 설계가 필요하다.
- 디버깅이 까다롭다.
- 단일 프로세스 시스템의 경우 효과를 기대하기 어렵다.
- 다른 프로세스에서 스레드를 제어할 수 없다. (즉, 프로세스 밖에서 스레드 각각을 제어할 수 없다.)
- 멀티 스레드의 경우 자원 공유의 문제가 발생한다. (동기화 문제)
- 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.

> **요약**
> 멀티 프로세스는 하나의 프로그램을 여러개의 프로세스로 구성하여 하나의 작업을 처리여 프로세스가 갑자기 종료되더라도 다른 프세스는 영향을 받지 않습니다만, 
> 
> 독립된 메모리 영역이기에 컨텍스트 스위치 비용이 발생합니다. 
> 
> 반면 멀티 스레드는 프로그램을 여러개의 쓰레드로 구성하여 작업을 처리합니다. 스레드간 데이터 공유가 쉽지만, 하나의 스레에 문제가 발생하면 다른 스레드가 영향을 받아 전체 프로세스가 영향을 받습니다.




</div>
</details>

<details>
<summary>Q. 멀티 프로세스로 처리 가능한 걸 굳이 멀티 스레드로 하는 이유는?</summary>
<div markdown="1">


![](https://i.imgur.com/pZ85MS5.png)

**자원의 효율성 증대**
멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
–> 프로세스 간의 Context Switching시 단순히 CPU 레지스터 교체 뿐만 아니라 RAM과 CPU 사이의 캐쉬 메모리에 대한 데이터까지 초기화되므로 오버헤드가 크기 때문
스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.

**처리 비용 감소 및 응답 시간 단축**
또한 프로세스 간의 통신(IPC)보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어든다.
–> 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문
프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다.
–> Context Switching시 스레드는 Stack 영역만 처리하기 때문

<span style="background:#fff88f">주의할 점!</span>

**동기화 문제**
스레드 간의 자원 공유는 전역 변수(데이터 세그먼트)를 이용하므로 함께 상용할 때 충돌이 발생할 수 있다.



</div>
</details>

<details>
<summary>Q.Context Swiching이란 무엇인가요?</summary>
<div markdown="1">

<span style="background:#fff88f">** Context Switching란?**</span>
CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 데 이 과정을 Context Switching라 한다. 
구체적으로, 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태(Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말한다.

![](https://i.imgur.com/jqyMIXP.png)


</div>
</details>


<details>
<summary>Q.교착상태(DeadLock)가 무엇이며, 4가지 조건은?</summary>
<div markdown="1">

![](https://i.imgur.com/khT3h2T.png)

### 교착상태란 
교착상태(Dead Lock)은 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상을 의미한다.

#### 교착상태 발생 조건

주로 멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황에서 발생한다.

교착상태가 발생하기 위해서는 다음의 네가지 조건이 충족되어야 하는데, 이 네가지 조건 중 하나라도 충족되지 않으면 교착상태가 발생하지 않는다.

#####  1. 상호배제(Mutual Exclusion)

<span style="background:#fff88f">자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다</span>. 상호 배제 기법에는 뮤텍스, 세마포어 등이 있다.

##### 2. 점유와 대기(Hold and Wait)

최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해<u> 대기하는 프로세스가 있어야 한다</u>.

##### 3. 비선점(Non-preemption)

다른 프로세스에 할당된 자원은 사용이 끝날 때까지 <u>강제로 빼앗을 수 없어야 한다</u>.

##### 4. 환경 대기(Circular Wait)

서로 다른 공유 자원을 사용하기 위해 **대기하는 프로세스들이 원형으로 구성(순환형태)**되어 있어 자신에게 할당된 자원을 점유하면서<u> 앞이나 뒤에 있는 프로세스의 자원을 요구</u>한다.


####  **🚀 데드락 예방(Prevention)**

**데드락의 발생조건 4가지 중 하나라도 발생하지 않게 하는 것**이 데드락을 예방하는 방법입니다. 즉, 각각의 조건을 방지(부정)하여 데드락 발생 가능성을 차단합니다.

- **자원의 상호 배제 조건** 방지 : 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 합니다.
    - 그러나 추후 동기화 관련 문제가 발생할 수 있습니다.
- **점유 대기 조건 방지** : 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 합니다.
    
- **비선점 조건 방지** : 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 합니다.

- **순환 대기 조건 방지** : 자원을 순환 형태로 대기하지 않도록 <u>일정한 한 쪽 방향</u>으로만 자원을 요구할 수 있도록 합니다.



</div>
</details>

<details>
<summary>Q.뮤텍스, 세마포어가 뭔지, 차이점은?</summary>
<div markdown="1">

여러 프로세스가 동시에 공유 데이터에 접근할 때 접근 순서에 따라 실행 결과가 달라지는 상황에 놓인 프로세스들을 경쟁상태(reace condition)에 있다고 한다. 이러한 경쟁상태를 예방하려면, 병행 프로세스들을 동기화 해야 하는데, 이는 임계 영역을 이용한 상호 배제로 구현할 수 있다. 

> **임계영역** 
> 여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유데이터를 접근하는 프로그램 코드 부문 

여기서 뮤텍스와 세마포어가 바로 상호 배제의 방법들 중 하나이다. 

###  뮤텍스(mutex)

뮤텍스는 Key 에 해당하는 어떤 오브젝트가 있으며 이 오브젝트를 소유한 (쓰레드,프로세스) 것 만이 공유자원에 접근할 수 있다.

![](https://i.imgur.com/8nwyKeN.png)

다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 locking 과 unlocking 을 사용한다. 즉, 쉽게 말하면 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없다는 의미이다.

- lock : 현재 임계 구역에 들어갈 권한을 얻어옴( 만약 다른 프로세스/스레드가 임계 구역 수ㅇ중이면, 종료할 때까지 대기)
- unlock : 현재 입계 구역을 모두 사용했음을 알림. (대기중인 다른 프로세스/스레드가 임ㅖ구역에 진입할 수 있음.)

##### 과정

- 1번 프로세스가 자원을 접근하기 위해 Key를 점유한다.
    
- 1번 프로세스는 키를 점유했기 때문에 공유 자원을 사용한다.
    
- 2번 프로세스가 공유 자원을 사용하기를 원한다.
    
- 2번 프로세스는 키를 점유하기 위해 대기한다.
    
- 3번 프로세스 또한 공유 자원을 사용하기 위해 2번 프로세스 다음 순번으로 대기한다.
    
- 1번 프로세스가 공유 자원을 다 사용하고 Key를 반환한다.
    
- 2번 프로세스는 대기하고 있다가 반환된 Key를 점유하고 공유 자원을 사용한다.


**(예시)**

![](https://i.imgur.com/6q9ueph.png)
프로세스는 자원에 접근하기 위해 열쇠(lock)를 얻고 화장실(자원)을 쓴다.
다 쓰고 키(unlock)을 반납한다. 

뮤텍스에서는 3가지 알고리즘을 사용한다고 한다.
1. 데커알고리즘
2. 피터슨 알고리즘
3. 제과점 알고리즘 



### 세마포어란?
공유 자원에 대한 접속을 제어하기 위해 최대 허용치만큼 접근 요청을 가능하게 하여 카운트를 세서 카운트가 0이되면 대기하도록 하여 상호 배제를 달성하는 기법입니다.

![](https://i.imgur.com/w88Hkst.png)

앞선 방법들과의 차이점을 제시하자면,
앞선 방법은 프로세스가 임계 영역에 진입할 수 없을 때 진입 조건이 true 가 될 때까지 반복적으로 조사하고 바쁜 대기를 하기 때문에 프로세스를 낭비한다. 따라서, 진입 조건을 반복 조사하지 않고 true일때 프로세스 상태를 확인한다면, 프로세서 사이클을 낭비하지 않을 것입니다.

##### 과정

- 공유 자원에 대한 최대 허용치를 정의한다. 우선, 3으로 해보겠다.
    
- 1번 프로세스가 공유 자원에 접근한다. 허용치는 2로 감소하였다.
    
- 2번 프로세스가 공유 자원에 접근한다. 허용치는 1로 감소하였다.
    
- 3번 프로세스가 공유 자원에 접근한다. 허용치는 0로 감소하였다.
    
- 4번 프로세스가 공유 자원에 접근한다. 허용치가 0이므로 대기한다.
    
- 2번 프로세스가 공유 자원을 다 사용하였다. 허용치는 1로 증가하였다.
    
- 4번 프로세스는 대기 하다 허용치가 1로 증가되어 공유 자원에 접근한다. 허용치는 다시 0으로 감소하였다.



이또한 예시를 통해 알아봅시다.

![](https://i.imgur.com/o4BH3M6.png)
위 그림은 카운팅 세마포어를 쉽게 이해할 수 있는 예시입니다. 즉, 유한한 개수를 가진 자원에 대한 접근을 제어하는데에 사용할 수 있습니다. 

그리고 다른 방법은 이진 세마포어가 있습니다. 세마포어의 초기 값이 0 또는 1만 가질 수 있는 세마포어 입니다. (뮤텍스가 이진 세마포어와 비슷한 것이라 생각하면 됩니다.)


### 뮤텍스와 세마포어의 차이

- 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다.
    
- 세마포어는 소유할 수 없으며, 뮤텍스는 소유할 수 있고 소유주가 그에 대한 책임을 가진다.
    
- 세마포어는 동기화 대상이 여러개 일 때 사용하고, 뮤텍스는 동기화 대상이 오로지 하나 일 때 사용된다.



</div>
</details>

<details>
<summary>Q.PCB란 무엇이고, 왜 필요한지?</summary>
<div markdown="1">

#### **PCB (Process Control Block)**

PCB(프로세스 제어 블록)는 운영체제에서 프로세스를 관리하기 위해 해당 프로세스의 상태 정보를 담고 있는 자료구조를 말한다.

프로세스를 컨텍스트 스위칭 할때 기존 프로세스의 상태를 어딘가에 저장해 둬야 다음에 똑같은 작업을 이어서 할 수 있을 것이고, 새로 해야 할 작업의 상태 또한 알아야 어디서부터 다시 작업을 시작할지 결정할 수 있을 것이다. 즉, PCB는 프로세스 스케줄링을 위해 프로세스에 관한 모든 정보 저장하는 **임시 저장소**인 것이다. 

![](https://i.imgur.com/5LZ83z1.png)

따라서 운영체제는 PCB에 담긴 프로세스 고유 정보를 통해 프로세스를 관리하며, 프로세스의 실행 상태를 파악하고, 우선순위를 조정하며, 스케줄링을 수행하고, 다른 프로세스와의 동기화를 제어한다. 

운영체제에 따라 PCB에 포함되는 항목이 다를 수 있지만 일반적으로 PCB내 에는 다음과 같은 정보가 포함되어 있다.

![](https://i.imgur.com/vh9Kho9.png)


##### context switching 과정 
![](https://i.imgur.com/sJMt2zS.png)



</div>
</details>


<details>
<summary>Q. 스택, 데이터, 코드에 대해 설명해주세요.</summary>
<div markdown="1">

   ![](https://i.imgur.com/MIUCWIZ.png)

- **코드 영역(Code / Text)** : 프로그래머가 작성한 프로그램 함수들의 코드가 CPU가 해석 가능한 기계어 형태로 저장되어 있다.
- **데이터 영역(Data)** : 코드가 실행되면서 사용하는 전역 변수나 각종 데이터들이 모여있다. 데이터영역은 .data ,.rodata, .bss 영역으로 세분화 된다.
    - .data : 전역 변수 또는 static 변수 등 프로그램이 사용하는 데이터를 저장
    - .BSS : 초기값 없는 전역 변수, static 변수가 저장
    - .rodata : const같은 상수 키워드 선언 된 변수나 문자열 상수가 저장
- **스택 영역(Stack)** : 지역 변수와 같은 호출한 함수가 종료되면 되돌아올 임시적인 자료를 저장하는 독립적인 공간이다. Stack은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다. 만일 stack 영역을 초과하면 stack overflow 에러가 발생한다.
- **힙 영역(Heap)** : 생성자, 인스턴스와 같은 동적으로 할당되는 데이터들을 위해 존재하는 공간이다. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다.


</div>
</details>


<details>
<summary>Q.사용자 수준 스레드 vs 커널 수준 스레드 차이는?</summary>
<div markdown="1">

### 사용자 수준 스레드
사용자 레벨 라이브러리를 통해 구현된 스레드로, 커널 영역 위에서 동작합니다.
이 스레드는 스레드를 관리하는 라이브러리로 인해 사용자 단에서 생성 및 관리되는 스레드입니다.  
그래서 커널이 따로 관리하지 않고, 커널이 이 스레드에 대해서 알지도 못합니다.

한 마디로 커널 레벨 밖에 있는 스레드.

이것은 실제 물리적으로 정말 커널 밖에 있고 그런 것이 아니라, 전부 커널 내부에 있지만 커널의 통제권 안에 있는지 차이인 것입니다.   
커널에는 '커널 모드'와 '사용자 모드' 두 가지가 있고, 여기서 '사용자 모드'에서 동작하는 스레드가 사용자 수준 스레드인 것입니다.
![](https://i.imgur.com/Vl4Jevn.png)

입출력 인터럽트가 발생하면 커널은 '사용자 모드'가 되어서 사용자 수준 스레드의 응답을 기다린다. 사용자 수준 스레드의 응답이 오면 다시 '커널 모드'로 변환되어 이어서 커널 스레드가 일 처리를 하게 되는 것이다.

#### 장점
스레드 관련 작업시 커널을 호출하지 않아 오버헤드가 낮습니다.
커널에 독립적으로 스케줄링 가능하여 모든 운영체제에 적용이 가능합니다.

#### 단점
커널이 스레드 관리에 직접 개입하지 못함
User mode 에서 실행되어, System Call 발생 시 대응이 안좋습니다. 

![](https://i.imgur.com/KQd5iHQ.png)






### 커널 수준 스레드 
커널 레벨에서 생성되는 스레드로, 커널이 스레드와 관련된 모든 작업을 직접 관리합니다.

#### 장점
모든 스레드가 system call 로 구현이 가능합니다.
커널이 직접 스레드와 관련된 모든 작업을 처리합니다. 

#### 단점
커널 단 수행시간이 오래걸려 오버헤드가 높습니다.
![](https://i.imgur.com/jCOFNAG.png)


커널 수준에서는 프로세스가 주기억 장치에 여러 개가 적재되어 CPU 할당을 기다리며 동작합니다.

CPU에서 인터럽트 발생으로 현재 작업 중인 프로세스가 Block 되고 다른 프로세스로 변경할 때, CPU 내 재배치 레지스터에 다음에 실행할 프로세스 정보들로 교체를 하고 캐시를 비운다. 이 것을 **컨텍스트 스위칭**이라고 한다.

이 컨텍스트 스위칭이 일어날 때는 CPU가 일을 못하게 됩니다. 그래서 이게 자주 일어나면 성능에 영향이 발생하게 되는 단점이 있습니다.  
하지만 커널이 직접 관리하므로 특정 스레드가 Block이 되어도 다른 스레드들은 독립적으로 일을 할 수 있습니다.





</div>
</details>

<details>
<summary>Q. 4 CPU 환경에서 4개의 쓰레드가 실행된다고 가정해보자. 어떤 문제가 발생할 수 있겠는가?</summary>
<div markdown="1">


4코어 4스레드의 cpu 환경에서 작업이 여러개 진행된다면, 


</div>
</details>


<details>
<summary>Q.동기와 비동기의 차이?</summary>
<div markdown="1">

### 동기 
동기는 사전적으로 '동시에 일어난다' 라는 의미를 갖고있습니다.
프로그래밍에서 동기는 작업이 순차적으로 진행되는 것을 의미합니다.
즉, 한 작업이 시작되면, 해당 작업이 완료될 때까지 다른 작업이 기다려야합니다.
동기 방식은 호출한 함수 또는 작업이 반환될 때까지 실행 흐름이 차단되는 특징이 있습니다. 

동기 방식은 일반적으로 간단하고, 직관적인 코드를 작성하기 쉽습니다. 하지만 여러 작업이 동시에 실행되어야 하는 경우 각 작업의 완료를 기다리는 동안, 시간이 소요되어 전체 프로세스의 성능이 저하될 수 있습니다.
또한 한 작업이 지연되면, 다른 작업들도 모두 지연되는 문제가 발생할 수 있습니다. 

### 비동기

비동기는 사전적으로 '동시에 일어나지 않는다' 는 의미를 가지고 있습니다. 프로그래밍에서 비동기는 작업이 독립적으로 실행되며, 작업의 완료 여부를 기다리지 않고 다른 작업을 실행할 수 있는 방식을 의미합니다. 

즉, 비동기 방식은 작업이 시작되면 해당 작업이 완료될 때까지 기다리지 않고, 다음 코드를 실행할 수 있습니다. 비동기 방식은 주로 I/O 작업이나 네트워크 요청과 같이 시간이 오래걸리는 작업에 유용합니다.
이러한 작업을 비동기적으로 처리하면, 프로그램은 작업이 완료되기를 기다리는 동안 다른 작업을 처리할 수 있으므로 전체적인 성능이 향상됩니다. 
비동기 방식은 콜백(callback), 프라미스(Promise), async/await 등의 메커니즘을 통해 구현될 수 있습니다. 

> 요약
> 동기방식은 작업을 순차적으로 처리하며, 다음 작업을 실행하기 위해 이전 작업의 완료를 기다립니다.
> 반면에, 비동기 방식은 작업을 독립적으로 실행하며, 다른작업을 실행하면서 작업의 완료를 기다리지 않습니다. 
> 동기와 비동기의 선택은 프로그램의 요구사항과 성능에 따라 달라집니다. 


</div>
</details>




---
### 리눅스
<details>
<summary>Q. SAN, NAS, DAS의 차이..</summary>
<div markdown="1">

> DAS, NAS, SAN이란?

다스, 나스, 샌이란 스토리지의 종류이고, 연결방식의 차이가 있습니다.

각 스토리지는 어떻게 연결되는지, 어떤 방식의 차이인지 알아보겠습니다.

​

**DAS와 NAS**

DAS와 NAS는 하드디스크를 여러개 장착가능한 <span style="background:#fff88f">데이터 스토리지</span>이며,

DAS는 유선으로 외장하드처럼, NAS는 와이파이나 랜으로 무선의 클라우드처럼 사용됩니다.

​

**DAS(외장하드, Direct Attached Stoage)**
![](https://i.imgur.com/6s7LVkv.png)

PC나 서버에 다이렉트로 꽂아서(USB처럼) 사용하는 스토리지.

서버와 하드웨어를 1:1로 연결.

각 서버는 자신이 직접 파일 시스템을 관리합니다.

쉽게말해 하드를 여러개 끼울 수 있는 서버의 외장하드를 의미합니다.

서버에 직접 외장저장장치를 연결하므로 속도는 빠르고 확장은 쉽지만, 연결 수에 한계가 있습니다.



**NAS ( 클라우드와 유사, Network Attached Storage )**

쉽게 말해 DAS에 네트워크 기능이 탑재된것과 같습니다.
![](https://i.imgur.com/ipJHHBo.png)

​

서버와 저장장치가 이더넷등의 LAN방식의 네트워크에 연결된 방식입니다.

LAN은 TCP/IP 프로토콜 기반이고 저장장치는 SCSI를 사용하므로 이들 간 통신을 위해

중계역할을 하는 파일서버가 필요합니다.

스토리지 내에서 직접 파일을 읽기/쓰기/공유 합니다.

​

[ LAN( Local Area Network, 근거리 통신망)

- 광대역 통신망과는 달리 학교, 회사, 연구소 등 한 건물이나 일정 지역 내에서 컴퓨터나 단말기들을 고속 전송 회선으로 연결하여 프로그램 파일 또는 주변장치를 공유할 수 있도록 한 네트워크 형태

SCSI( small computer system interface )

- 컴퓨터 주변기기 접속을 위한 직렬 표준 인터페이스 ]

​

장점: DAS와 달리 PORT수 제한이 없어 확장성과 유연성이 뛰어남

경제적 유리, 설치/유지보수 용이

단점: 접속증가 시 성능저하, 전송속도 DAS보다 느림.

파일시스템 공유하기때문에 보안 비교적 취약. 백엄이 어려움.



​

**SAN ( Storage Area Network )**

서버와 저장장치를 NAS와는 다르게 ( NAS는 표준 이더넷 연결 )

Fiber channel( 광채널 ) switch로 연결한 고속데이터 네트워크

​

저장장치를 향상시켜 장치가 로컬 연결장치로 서버의 운영체제에 표시되도록 합니다.

​

**DAS와 NAS의 단점 보완**.

서버당 접속 스토리지 수 제한 해결.

전용 파이버채널 스위치( 광채널 )을 둠으로써 빠른 속도의 연결을 유지하는 것이 특징입니다.
![](https://i.imgur.com/X2E88vK.png)



</div>
</details>

<details>
<summary>Q. OOM 정의와 발생 원인과 해결 방법.</summary>
<div markdown="1">

Linux의 swap 메모리와 물리 메모리를 모두 사용 중 일 때, 프로세스에서는 필요에 의해 추가적인 물리 메모리 할당을 요청하였는데, <span style="background:#fff88f">더 이상 할당할 물리 메모리 공간이 없어 할당이 불가능한 상태를 의미한다</span>. 즉 메모리 Over Commit 상태일 때 발생하는 현상으로 물리적으로 메모리가 부족하다는 뜻이다. 이러한 문제는 물리 메모리만 증설하면 사실 간단히 해결된다. 하지만 왜 이러한 현상이 발생하는지 원인을 찾지 못한 상태에서 무한정 메모리를 증설할 수도 없다.

해결 방법 😀:
리눅스 커널이 메모리를 확보하기 위해 실행하는 OOM Killer 를 이용합니다.
OOM Killer 는 점수를 매겨 가장 높은 점수를 받은 프로세스 부터 강제 종료합니다. 
이를 OOM Scoring 이라고 하는데요, 특정 프로세스의 점수는 /proc/${pid}/oom_score 파일을 통해 조회할 수 있습니다.

[프로세스의 점수 산정 기준]
1. 완료된 작업의 수를 최대로 유지해야 한다.
2. 많은 양의 메모리를 복구한다.
3. 메모리를 많이 소비하지 않은 프로세스는 죽이지 않는다.
4. 최소한의 프로세스만 죽인다.
5. 사용자가 지정한 프로세스를 죽이려 시도한다.





[나중에 볼 링크](https://blog.naver.com/hanajava/223133077977)
[나중에 볼 링크2](https://hbase.tistory.com/319)

</div>
</details>

<details>
<summary>Q.ssh 인증 방식에 대해 설명해주세요.</summary>
<div markdown="1">

SSH 프로토콜은 안전한 원격 접속과 보호되지 않은 네트워크에서 안전한 네트워크 서비스를 제공하기 위해 **암호화를 사용합니다.**

암호화를 통해, 호스트(클라이언트)와 원격지(서버)간의 연결(사용자 인증, 명령, 파일 전송)을 네트워크 공격으로부터 보호할 수 있는데요.

SSH 프로토콜은 클라이언트-서버 모델로 동작하며 **대칭키 방식, 비대칭키 방식, 해시 알고리즘을 사용**하여 인증 및 암호화를 수행합니다.

**대칭키 방식은 클라이언트-서버 간 전체 연결을 암호화에 사용**되며,

**비대칭키 방식은 키 교환, 클라이언트 인증, 서버 인증에 사용**되고,

**해시 알고리즘은 패킷의 무결성을 확인하기 위해 사용**됩니다. (HMAC : Hash based Message Authenticated Codes)

![](https://i.imgur.com/YOWxDuJ.png)

**1. 클라이언트는 서버에 원격 접속하기 위해 연결을 설정하는 프로세스를 시작한다.**
**2. 서버는 자신의 공개키를 클라이언트에게 전송한다.**
**3. 클라이언트와 서버는 여러 Parameter들을 주고 받으며 보안 채널을 확립한다.**
**3.1 올바른 서버인지 확인(클라이언트 관점)**
**3.2 암호화된 통신을 위한 세션키 생성(대칭키 생성)**
SSH에서 사용하는 대표적인 **키****교환 알고리즘인 디피-헬만(Diffie-Hellman : DH) 알고리즘**은 상대방의 공개키와 나의 개인키를 통해 대칭키를 얻는 방법입ㄴ디ㅏ.
**[주의] 대칭키 교환에 사용되는 키 쌍은 서버와 클라이언트 인증에 사용되는 SSH 키 쌍과 다름**

SSH가 DH를 통해 얻은 대칭키는 **개별 세션에 대해 생성되며 더 이상 필요하지 않은 즉시 사라진다.** 

따라서 클라이언트나 서버의 개인키가 유출되어도 이전 세션키를 통해 수행한 통신 내용을 복호화할 수 없다.

이는 TLS 세션에서도 사용되는 구성으로 인증서에 만료 날짜가 있는 경우 개인키는 중간자 공격으로 인해 유출되어도 인증서가 만료되었을 시 사용할 수 없으므로 만료 후에는 강한 보안 유지를 하지 않아도 된다.
**3.3 서버에 접근할 수 있는 클라이언트인지 확인(서버 관점)**
- ssh 키 쌍을 사용하여 클라이언트를 확인한다.




</div>
</details>

<details>
<summary>Q.SeLinux가 무엇이고, 장점과 단점에는 무엇이 있는가?.</summary>
<div markdown="1">

- 리눅스는 소스코드가 공개되어 있어 보안이 취약한데 취약점을 보완한 것이 SELinux이다.
- Linux의 핵심인 Kernel을 보호하기 위한 도구이다. (Linux Kernel 모듈)
- 기존 접근 통제 규칙보다 우선으로 동작하여 SELinux의 보안 정책에 맞지 않을 경우 차단한다. 
- 3가지 상태가 존재한다.
    
    - enforcing : 강제
    - permissive : 허용
    - disabled : 비활성화

### [✔️ SELinux 장점](#✔️-SELinux-장점)

**<span style="background:#d3f8b6">1. 사전 정의된 접근 통제 정책 탑재</span>**

사용자, 역할, 타입, 레벨등의 다양한 정보를 조합하여 어떤 프로세스가 어떤 파일, 디렉터리, 포트등에 접근 가능한지에 대해 **사전에 잘 정의된 접근 통제 정책이 제공**된다. 

**MAC 적용을 위해 시스템 관리자가 할 일이 대폭 줄었고** 애플리케이션의 변경없이 setuid와 1024 이하 포트를 사용하는 데몬을 안전하게 사용할 수 있다. 

**2. <span style="background:#d3f8b6">"Deny All, Permit Some" 정책으로 잘못된 설정 최소화</span>**

"모든 걸 차단하고 필요한 것만 허용"하는 정책은 단순하면서 강력한 정보 보호를 위한 최선의 정책이다.

SELinux 의 보안 정책도 이 방식으로 사전에 설정되어 있으므로 잘못된 설정이 기본 포함돼 있을 여지가 적다.

**3. <span style="background:#d3f8b6">권한 상승 공격에 의한 취약점 감소</span>**

setuid 비트가 켜져 있거나 루트로 실행되는 프로세스처럼 위험한 프로그램들은 샌드박스안에서 별도의 도메인으로 격리되어 실행되므로 루트 권한을 탈취해도 해당 도메인에만 영향을 미치고 전체 시스템에 미치는 영향이 최소화된다.

ex) 아파치 httpd 서버의 보안 취약점을 통해 권한을 획득했어도 아파치같은 서버 데몬은 낮은 등급의 권한을 부여 받으므로 공격자는 일반 사용자의 홈 디렉터리를 읽을 수 없고 /tmp 임시 디렉터리에 파일을 쓸 수가 없다.

**4. <span style="background:#d3f8b6">잘못된 설정과 버그로부터 시스템 보호</span>**

잘못된 설정이나 신뢰할 수 없는 입력을 악용한 공격에서 프로세스를 보호할 수 있다.

ex) 버퍼의 입력 길이등을 제대로 체크하지 않아서 발생하는 버퍼 오버 플로 공격(buffer overflow attack)의 경우 SELinux 는 어플리케이션이 메모리에 있는 코드를 실행할 수 없게 통제하므로 데몬 프로그램에 버퍼 오버 플로 버그가 있어도 쉘을 얻을 수가 없다.

### [✔️ SELinux 의 한계](#✔️-SELinux-의-한계)

SELinux 의 주요 목표는 잘못된 설정이나 프로그램의 보안 버그로 인해 시스템이 공격 당해도 시스템과 데이터를 보호하고 2차 피해를 막는 것이다.

SELinux 는 여러 가지 보안 요소중에 하나이며 SELinux 로 모든 보안 요건이 충족되지는 않는다.

SELinux 는 침입 차단 시스템(IPS : Intrusion Protection System), 침입 탐지 시스템(IDS : Intrusion Detection System)이나 바이러스 백신이 아니므로 여러 보안 요소와 혼용하여 사용해야 한다. 

출처 : [뭉게뭉게 클라우드:티스토리](<https://nice-engineer.tistory.com/entry/Linux-SELinux-Security-Enhanced-Linux](https://nice-engineer.tistory.com/entry/Linux-SELinux-Security-Enhanced-Linux>)

</div>
</details>

<details>
<summary>Q.리눅스 파일 권한과 사용자 관리는 어떻게 이루어지나요?.</summary>
<div markdown="1">

### 리눅스 파일 권한 관리

- 리눅스는 멀티 유저 운영체제이므로 파일과 디렉토리의 권한 관리가 중요합니다.
- `ls -l` 명령어로 파일과 디렉토리의 권한을 확인할 수 있습니다.
<span style="background:#fff88f">-<font color="#0c0c0c"> 권한은 읽기(r), 쓰기(w), 실행(x)으로 구성되며, 소유자, 그룹, 기타 사용자로 구분됩니다.</font></span>
- `chmod` 명령어로 파일과 디렉토리의 권한을 변경할 수 있습니다.
- 특수 권한인 SetUID, SetGID, Sticky-Bit 등도 관리할 수 있습니다.

### 리눅스 사용자 관리

<font color="#0c0c0c"><span style="background:#fff88f">- 리눅스 사용자는 root 사용자와 일반 사용자로 구분됩니다.</span></font>
<font color="#0c0c0c"><span style="background:#fff88f">- root 사용자는 모든 권한을 가지며, 일반 사용자는 root가 부여한 권한 내에서만 작업할 수 있습니다.</span></font>
- 사용자 계정은 UID(User ID)로 관리되며, root는 UID 0, 일반 사용자는 1부터 시작합니다.
- 시스템 계정과 솔루션 계정도 존재하며, `/etc/passwd` 파일에 저장됩니다.
- `useradd`, `userdel`, `usermod` 등의 명령어로 사용자 계정을 관리할 수 있습니다.
- `su`, `sudo` 명령어로 사용자를 전환할 수 있습니다.

### 사용자 그룹 관리

<span style="background:#fff88f"><font color="#0c0c0c">- 사용자를 그룹으로 묶어 관리할 수 있습니다.</font></span>
- `groupadd`, `groupdel`, `groupmod` 명령어로 그룹을 관리할 수 있습니다.
- 사용자를 그룹에 추가하거나 제거할 수 있습니다.
- 그룹 권한을 통해 여러 사용자에게 일괄적으로 권한을 부여할 수 있습니다.

요약하면, 리눅스는 파일과 디렉토리의 권한 관리, 사용자 계정 관리, 그룹 관리 등을 통해 보안을 강화할 수 있습니다. 이를 위해 다양한 명령어와 설정 파일을 활용할 수 있습니다.

</div>
</details>

<details>
<summary>Q.리눅스의 특수 권한에 대해서 설명해주세요.</summary>
<div markdown="1">

### 특수 권한(setuid, setgid, sticky bit)

- 프로세스에 부여되는 번호들:
    - 프로세스 식별자(PID)
    - 실제 사용자 ID(RUID)
    - 유효 사용자 ID(EUID)
    - 실제 사용자 그룹(RGID)
    - 유효 사용자 그룹 ID(EGID)
- 사용 용도:
    - 계정 관리
    - 접근 권한 결정
- 권한 관리 명령어:
    - `chmod`: 파일/디렉토리 권한 변경
    - `umask`: 새로 생성되는 파일/디렉토리의 기본 권한 설정
    - `chown`: 파일/디렉토리 소유자 변경
    - `chgrp`: 파일/디렉토리 소속 그룹 변경

### setuid (Set User ID)

- 실행 파일에 부여할 수 있는 특수 권한
- 실행 시 파일 소유자의 권한으로 동작
- 일반 사용자가 root 권한이 필요한 작업을 수행할 수 있게 해줌
- 보안상 주의가 필요하며, 최소한의 권한만 부여해야 함

### setgid (Set Group ID)

- 디렉토리에 부여할 수 있는 특수 권한
- 새로 생성된 파일/디렉토리가 디렉토리 소유 그룹을 상속
- 그룹 단위 협업 시 유용

### Sticky Bit

- 디렉토리에 부여할 수 있는 특수 권한
- 777 권한의 디렉토리에서 파일 삭제 권한을 제한
- 다른 사용자가 해당 디렉토리의 파일을 삭제하지 못하도록 함

이와 같이 리눅스의 특수 권한은 보안과 편의성을 높이는 데 활용됩니다. 하지만 잘못 사용하면 보안 문제가 발생할 수 있으므로 주의해서 관리해야 합니다.

</div>
</details>

<details>
<summary>Q.swap 메모리에 대해 설명하라.</summary>
<div markdown="1">

리눅스에서의 Swap 메모리도 앞서 설명한 것처럼 메모리 사용량이 늘어남에 따라 디스크 일부를 마치 확장한 RAM 처럼 사용하게 해 줍니다.

리눅스 커널은 실제 메모리에 올라와 있는 메모리 블록들 중 당장 쓰이지 않는 것을 디스크에 저장하고, 이를 통해 사용 가능한 메모리 영역을 늘립니다.

</div>
</details>

<details>
<summary>Q.ebpf 의 개념과 활용 예시에 대해 설명하라.</summary>
<div markdown="1">

### BPF: Berkely Packet Filter

BPF는 1992년에 패킷 필터로 패킷을 분석하고 필터링하는데에 사용되는 in-kernel virtual machine입니다. BSD에서 처음 도입했으며 리눅스에서도 이 개념을 빌려와서 서브시스템을 만들었습니다. in-kernel virtual machine이라고 함은 정말로 가상의 레지스터와 스택 등을 갖고 있으며 이를 바탕으로 코드를 실행한다는 뜻입니다.

> 요약 : 네트워크 트래픽을 분석해야 하는 프로그램을 위해 특정 OS에서 사용되는 기술입니다. 이름 그대로 패킷을 걸러내는 필터


### eBPF: extended BPF

eBPF는 확장 BPF라는 뜻입니다. 기존의 BPF에서 사용하던 머신에서 더 나아가서 레지스터의 크기를 늘려주고 스택과 맵을 도입하는 등의 변화가 있었습니다. 그래서 기존의 BPF를 cBPF (classic BPF)라고 부르고 새로운 BPF를 eBPF로 부르게 되었습니다.

eBPF는 다양한 종류의 트래픽에 걸쳐 작동하므로 통합 관찰가능성이라는 기업의 목표를 달성하는 데 큰 도움이 됩니다. 예를 들어, 데브옵스 엔지니어는 전체 트레이스 요청, 데이터베이스 질의, HTTP 요청, gRPC 스트림 수집은 물론 CPU 사용량이나 전송 바이트 수와 같은 자원 활용 지표(메트릭스) 수집에도 eBPF를 활용할 수 있습니. 따라서 해당 기업은 관련 통계를 산출하고 데이터의 개요를 파악해 다양한 기능의 자원 소모 현황을 이해할 수 있게 됩니다. 또한, eBPF는 암호화된 트래픽을 처리할 수 있습니다.

출처 : 
- [첫번째](https://kim-dragon.tistory.com/274)
- [두번째](https://hyeyoo.com/133)

</div>
</details>


<details>
<summary>Q.물리 서버에 접속은 되고 (즉 명령어는 실행할 수 있고), 애플리케이션 기능은 제대로 동작하지 않는 상황에서 무엇을 체크해볼 것인가? 생각나는 대로 대답하라.</summary>
<div markdown="1">

1. **서버 상태 확인**
    
    - 서버 리소스 사용량(CPU, 메모리, 디스크 등) 모니터링
    - 시스템 로그 확인을 통한 오류 및 이벤트 분석
    - 네트워크 연결 상태 점검
2. **애플리케이션 구성 확인**
    
    - 애플리케이션 설정 파일 점검
    - 데이터베이스 연결 상태 확인
    - 외부 서비스 연동 상태 점검
3. **애플리케이션 프로세스 확인**
    
    - 애플리케이션 프로세스 실행 여부 확인
    - 프로세스 로그 분석을 통한 오류 확인
    - 프로세스 리소스 사용량 모니터링
4. **네트워크 연결 확인**
    
    - 방화벽 설정 점검
    - 포트 및 프로토콜 연결 상태 확인
    - 외부 네트워크 연결 상태 점검
5. **운영체제 및 패키지 버전 확인**
    
    - 운영체제 버전 및 패치 상태 확인
    - 필요한 라이브러리 및 패키지 설치 여부 확인
6. **모니터링 및 로깅 설정 확인**
    
    - 애플리케이션 로그 설정 및 수집 상태 점검
    - 시스템 모니터링 도구 설정 및 경보 기능 확인

</div>
</details>

<details>
<summary>Q.좀비 프로세스에 대해 설명하라.</summary>
<div markdown="1">

좀비 프로세스는 부모 프로세스가 자식 프로세스를 제대로 종료하지 못할 때 발생합니다. 그런 상황은 보통 부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우 발생합니다. 원래 자식 프로세스는 부모 프로세스가 종료해줘야 합니다.

그렇다고 부모 프로세스가 먼저 종료된 모든 경우에 좀비 프로세스가 발생하는 건 아닙니다. 예를 들어 리눅스에선 컴퓨터가 실행될 때 init 또는 systemd라는 PID 1을 가진 프로세스가 존재하는데, 만약 부모 프로세스가 죽으면 init이 자동으로 남은 자식 프로세스의 부모 프로세스가 됩니다. 그럼 init은 기회가 될 때 프로세스를 종료시킬 수 있습니다.

즉 장기적으로 좀비 프로세스가 쌓인다는 건 전반적으로 시스템이 제대로 작동하지 못하고 있다는 의미로 해석할 수 있습니다.

</div>
</details>


<details>
<summary>Q.리눅스에서 가상화를 어떻게 구현할 수 있는지 설명하시오.</summary>
<div markdown="1">

## 리눅스 가상화 구현 방법

- 리눅스 가상화 기술은 KVM, Xen, VMware 등이 대표적입니다.
- 가상화를 통해 물리적 자원을 논리적으로 분리하여 사용할 수 있습니다.
- 이를 통해 자원 활용도 향상, 사용자 환경 격리, 대용량 스토리지 지원 등의 이점을 얻을 수 있습니다.

1. **호스트 OS에서 직접 구현**
    
    - 호스트 OS에 가상화 기술을 직접 설치하고 구성하는 방식입니다.
    - KVM(Kernel-based Virtual Machine)이 대표적인 예로, 리눅스 커널에 내장된 가상화 기능을 활용합니다.
    - 호스트 OS의 자원을 직접 관리하므로 성능이 우수하지만, 관리가 복잡할 수 있습니다.
2. **가상화 소프트웨어 사용**
    
    - 별도의 가상화 소프트웨어를 설치하여 가상 머신을 실행하는 방식입니다.
    - VMware ESXi, Xen Server 등이 대표적인 예입니다.
    - 가상화 소프트웨어가 자원을 관리하므로 사용이 편리하지만, 성능이 호스트 OS 직접 구현 방식보다 다소 낮을 수 있습니다.




</div>
</details>

<details>
<summary>Q.- 리눅스 서버에 원격으로 접근할 수 있는 방법과 장단점을 나열하시오.
.</summary>
<div markdown="1">

### 리눅스 서버 원격 접근 방법

1. **SSH(Secure Shell)**
    
    - **설명**: SSH는 안전한 원격 접속을 위한 프로토콜로, <font color="#0c0c0c"><span style="background:#affad1">암호화된 통신을 제공</span></font>합니다.
    - **장점**:
        - 안전한 원격 접속 가능
        - 터미널 환경에서 명령어 실행 가능
        - 파일 전송, 포트 포워딩 등 다양한 기능 지원
    - **단점**:
        - 초기 설정이 필요할 수 있음
        - 일부 방화벽 설정이 필요할 수 있음
2. **VNC(Virtual Network Computing)**
    
    - **설명**: VNC는 그래픽 사용자 인터페이스(GUI)를 통해 원격 데스크톱에 접근할 수 있는 프로토콜입니다.
    - **장점**:
        - <font color="#0c0c0c"><span style="background:#affad1">그래픽 환경에서 작업</span></font> 가능
        - 마우스와 키보드 입력이 가능
    - **단점**:
        - 네트워크 대역폭이 많이 필요
        - 보안이 SSH에 비해 취약할 수 있음
3. **웹 기반 원격 접근**
    
    - **설명**: 웹 브라우저를 통해 원격 서버에 접근하는 방식입니다.
    - **장점**:
        - 별도의 클라이언트 프로그램 없이 접근 가능
        - 웹 브라우저만 있으면 어디서든 접근 가능
    - **단점**:
        - 기능이 제한적일 수 있음
        - 보안 문제가 발생할 수 있음
4. **Telnet**
    
    - **설명**: Telnet은 텍스트 기반의 원격 접속 프로토콜입니다.
    - **장점**:
        - 간단한 사용법
        - 오래된 프로토콜이라 호환성이 좋음
    - **단점**:
        - 암호화가 되지 않아 보안이 취약함
        - 현재는 SSH가 더 많이 사용됨


</div>
</details>


<details>
<summary>Q.리눅스 배포본을 비교해보시오. (Red Hat, CentOS, Oracle Linux, SUSE, Ubuntu).</summary>
<div markdown="1">

1. **Red Hat Enterprise Linux (RHEL)**
    
    - **특징**: 기업용 배포본으로 안정성과 보안성이 뛰어남
    - **장점**: 강력한 기업 지원, 안정적인 업데이트 주기
    - **단점**: 유료 라이선스, 일부 기능 제한
2. **CentOS**
    
    - **특징**: RHEL과 호환되는 무료 배포본
    - **장점**: RHEL과 유사한 안정성, 무료 사용 가능
    - **단점**: 기업 지원 부족, 업데이트 주기가 RHEL보다 느림
3. **Oracle Linux**
    
    - **특징**: Oracle에서 제공하는 RHEL 호환 배포본
    - **장점**: RHEL과 호환성, Oracle 지원
    - **단점**: 유료 라이선스, 일부 기능 제한
4. **SUSE Linux Enterprise Server (SLES)**
    
    - **특징**: 기업용 배포본으로 안정성과 보안성이 뛰어남
    - **장점**: 강력한 기업 지원, 안정적인 업데이트 주기
    - **단점**: 유료 라이선스, 상대적으로 작은 커뮤니티
5. **Ubuntu**
    
    - **특징**: 데스크톱과 서버용으로 널리 사용되는 배포본
    - **장점**: 사용자 친화적, 활발한 커뮤니티, 무료 사용 가능
    - **단점**: 상대적으로 빠른 업데이트 주기, 기업 지원 부족

</div>
</details>

<details>
<summary>Q.FUSE와 파일시스템의 차이는? 성능 차이를 무시하고라도 FUSE는 쓸만한가?.</summary>
<div markdown="1">

FUSE(Filesystem in Userspace)는 사용자 공간에서 파일시스템을 구현할 수 있게 해주는 기술입니다. FUSE는 커널 수정 없이 사용자 공간에서 파일시스템을 구현할 수 있어 개발이 쉽고 빠르지만, 성능이 낮은 단점이 있습니다. 그러나 FUSE는 다양한 응용 분야에서 유용하게 활용될 수 있습니다.

## FUSE와 파일시스템의 차이

1. **구현 위치**
    
    - 일반 파일시스템: 커널 공간에서 구현
    - FUSE: 사용자 공간에서 구현
2. **성능**
    
    - 일반 파일시스템: 커널 공간에서 직접 처리되어 성능이 높음
    - FUSE: 사용자 공간에서 처리되어 성능이 상대적으로 낮음
3. **개발 용이성**
    
    - 일반 파일시스템: 커널 코드 수정이 필요해 개발이 복잡함
    - FUSE: 사용자 공간에서 구현되어 개발이 쉽고 빠름


</div>
</details>

---
## 아직 못한 것 
[  OS  ]

<details>
<summary>Q.가상 메모리란?</summary>
<div markdown="1">





</div>
</details>

<details>
<summary>Q.외부 단편화와 내부 단편화란?</summary>
<div markdown="1">


</div>
</details>

<details>
<summary>Q.페이징과 세그먼테이션이란?</summary>
<div markdown="1">


</div>
</details>

<details>
<summary>Q.비선점형(Non-preemptive) 스케줄링</summary>
<div markdown="1">


</div>
</details>
<details>
<summary>Q.선점형(Non-preemptive) 스케줄링</summary>
<div markdown="1">


</div>
</details>

<details>
<summary>Q.인터럽트란 무엇인가요?</summary>
<div markdown="1">


</div>
</details>

<details>
<summary>Q.운영체제한테 CPU가 넘어가는 경우는 언제인가?.</summary>
<div markdown="1">


</div>
</details>
<details>
<summary>Q.인터럽트 처리중에 또다른 인터럽트가 발생하는 경우는 어떻게 되는가?</summary>
<div markdown="1">


</div>
</details>

[  Linux ]

<details>
<summary>Q.리눅스의 메모리 할당 방식에 대해서 설명하시오..</summary>
<div markdown="1">


</div>
</details>

<details>
<summary>Q.리눅스의 네임스페이스가 무엇인가? (가상화 관련/도커 컨테이너등에서 사용).</summary>
<div markdown="1">


</div>
</details>


<details>
<summary>Q. kmalloc과 vmalloc의 차이점은 무엇인가?.</summary>
<div markdown="1">


</div>
</details>

<details>
<summary>Q.리눅스 부트 프로세스를 최대한 자세히 설명하시오. (하),(중).</summary>
<div markdown="1">


</div>
</details>


<details>
<summary>Q.대량의 서버를 사내에서 구입했다고 가정해보자. Ubuntu와 CentOS 중 무엇을 선택하겠는가?.</summary>
<div markdown="1">


</div>
</details>

<details>
<summary>Q. busybox가 무엇인가? 왜 사용하는가.</summary>
<div markdown="1">


</div>
</details>





### 가상화

<details>
<summary>Q.코드 가상화와 일반적인 가상화의 차이에 대해서 최대한 설명하시오.</summary>
<div markdown="1">


</div>
</details>
<details>
<summary>Q.리눅스를 가상화 서버에 올릴 때 어떤 점을 유의해야 할지?.</summary>
<div markdown="1">


</div>
</details>
<details>
<summary>Q.리눅스에서 가상화를 어떻게 구현할 수 있는지 설명하시오..</summary>
<div markdown="1">


</div>
</details>

<details>
<summary>Q.kvm, xen 등을 설명해본다..</summary>
<div markdown="1">


</div>
</details>
<details>
<summary>Q.써본 것 중에 어떤 가상화 하이퍼바이저가 어떤 서비스에서 좋았는지 ?.</summary>
<div markdown="1">


</div>
</details>
<details>
<summary>Q.리눅스 가상화에서 반가상화 드라이버는 무엇인지 설명하시오..</summary>
<div markdown="1">


</div>
</details>
<details>
<summary>Q.lguest에 대해서 아는지 물어본다..</summary>
<div markdown="1">


</div>
</details>
<details>
<summary>Q가상화의 장단점?..</summary>
<div markdown="1">


</div>
</details>
<details>
<summary>Q.Full virtualization(전가상화)과 Para-virtualization(반가상화)을 비교 설명하시오..</summary>
<div markdown="1">




</div>
</details>




---

### <u>Reference.</u>
- [기똥찬 프로세스/스레드 설명글](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4)
- [이것도 좋아요 프로세스/스레드](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html)
- [뮤텍스와 세마포어](https://incheol-jung.gitbook.io/docs/q-and-a/computer-science/undefined-1)
- [ssh 연결 참고](https://limvo.tistory.com/21)