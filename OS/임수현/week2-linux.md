# [ week2 ] 리눅스

<details>
<summary>ssh 인증 방식에 대해 설명해주세요</summary>

```
SSH 인증 방식은 사용자가 SSH 서버에 안전하게 접속하기 위한 방법을 말합니다. 
비밀번호 인증은 아이디와 비밀번호를 사용하여 로그인하는 기본 방식이며, 공개 키 인증은 공개 키와 개인 키를 사용하여 로그인하는 방식입니다. 
또한, 키 파일 인증은 키 파일을 사용하여 로그인하는 방식입니다. 
이 중 공개 키 인증이 가장 보안성이 높고 사용이 편리한 방법입니다.
```

```
SSH(Secure Shell)는 네트워크를 통해 안전하게 통신하기 위한 프로토콜입니다. SSH 인증 방식은 사용자가 SSH 서버에 안전하게 액세스하기 위해 사용되는 다양한 방법을 말합니다.

1. 비밀번호 인증(Password Authentication): 가장 기본적인 방법으로 사용자는 아이디와 비밀번호를 입력하여 서버에 로그인합니다. 이 방법은 간단하고 직관적이지만 보안 상의 취약점이 있을 수 있습니다.

2. 공개 키 인증(Public Key Authentication): 공개 키 인증은 대칭 키 암호화를 사용하여 보안을 강화하는 방법입니다. 사용자는 자신의 공개 키를 SSH 서버에 등록하고, 개인 키를 안전하게 보관합니다. 이후에 사용자는 공개 키를 사용하여 서버에 접속하고, 서버는 해당 사용자의 공개 키를 통해 인증을 수행합니다. 이 방법은 보안성이 높으며, 비밀번호 인증보다 안전합니다.

3. 키 파일 인증(Key File Authentication): 비밀번호나 공개 키 대신에 키 파일을 사용하여 인증하는 방법입니다. 사용자는 키 파일을 생성하고, 이 파일을 사용하여 SSH 클라이언트에 로그인합니다. 이 방법은 보안성이 높고, 사용자가 키 파일을 안전하게 보관하는 한에 비밀번호나 공개 키 인증보다 더욱 안전합니다.

SSH 인증 방식은 보안 수준과 사용자 편의성 간의 균형을 고려하여 선택되어야 합니다.
```

</details>

<details>
<summary>SeLinux가 무엇이고, 장점과 단점에는 무엇이 있는가?</summary>

```
SeLinux는 보안을 강화하기 위한 리눅스의 보안 모듈로, Mandatory Access Control(MAC)을 제공합니다.
(장점) SeLinux는 시스템의 리소스에 대한 접근을 엄격하게 제어하여 악성 코드의 확산을 막고 시스템의 안정성을 향상시킵니다.
(단점) 하지만 SeLinux 초기 설정이 복잡하고 일부 애플리케이션과의 호환성 문제가 있을 수 있으며, 시스템 리소스에 대한 엄격한 접근 제어로 인해 약간의 성능 저하가 발생할 수 있습니다.
```

</details>



<details>
<summary>리눅스 파일 권한과 사용자 관리는 어떻게 이루어지나요?</summary>

```
파일 권한은 각 파일과 디렉토리에 대한 소유자, 그룹, 그리고 다른 사용자에 대한 접근 권한을 설정합니다. 이를 통해 파일의 읽기, 쓰기, 실행과 같은 작업을 특정 사용자에게 허용하거나 제한할 수 있습니다. 
또한, 사용자 관리는 /etc/passwd와 /etc/shadow 파일 등을 통해 사용자 계정을 관리하고, 사용자에게 특정 그룹에 소속시키거나 권한을 부여할 수 있습니다. 
이러한 파일 권한과 사용자 관리를 통해 리눅스 시스템은 파일 접근을 제어하고 사용자 간의 리소스를 효과적으로 관리합니다.
```

</details>



<details>
<summary>리눅스의 특수 권한에 대해서 설명해주세요</summary>

```
리눅스의 특수 권한은 파일이나 디렉토리에 부여되며, 일반 파일 권한과는 달리 특정 작업을 허용하거나 제한합니다. 
주로 사용되는 특수 권한으로는 SetUID(SUID), SetGID(SGID), 그리고 Sticky Bit이 있습니다. 
SetUID는 파일을 실행할 때 파일 소유자의 권한으로 실행되게 하고, 
SetGID는 파일의 그룹 소유자의 권한으로 실행되게 합니다. 
Sticky Bit은 디렉토리에서 파일을 삭제하거나 이동할 때 특정 사용자만 가능하도록 제한합니다. 
```

</details>



<details>
<summary>swap 메모리에 대해 설명하라</summary>

```
swap 메모리는 주로 리눅스 시스템에서 물리적인 RAM이 부족할 때 사용되는 보조 메모리 공간입니다. 
RAM에 올릴 수 없는 프로세스 데이터나 사용되지 않는 프로세스의 데이터를 저장하기 위해 하드 디스크에 임시로 할당됩니다. 
이를 통해 시스템이 메모리 부족 상황에서도 정상적으로 동작할 수 있지만, 
하드 디스크에 접근하는 속도가 RAM보다 느리기 때문에 성능 저하를 초래할 수 있습니다. 
```

</details>



<details>
<summary>ebpf의 개념과 활용 예시에 대해 설명하라</summary>

```
eBPF는 리눅스 커널에서 실행되는 프로그램을 통해 시스템 동작을 제어하고 모니터링하는 기술입니다. 
예를 들어, 네트워크 트래픽 분석이나 악성 코드 탐지와 같은 작업을 수행할 수 있습니다. 또한, 시스템 리소스 모니터링과 최적화를 통해 성능을 향상시키는 데에도 사용됩니다. 
이러한 기술을 통해 eBPF는 커널 내에서 보다 안전하고 효율적인 작업을 가능하게 합니다.
```

</details>



<details>
<summary>물리 서버에 접속은 되고 (즉 명령어는 실행할 수 있고), 애플리케이션 기능은 제대로 동작하지 않는 상황에서 무엇을 체크해볼 것인가? 생각나는 대로 대답하라  </summary>

```
먼저, 애플리케이션 로그를 확인하여 어떤 문제가 발생했는지 파악하고, 시스템의 리소스 사용량을 살펴봅니다. 
네트워크 연결 상태를 확인하고, 서비스가 올바른 포트에서 실행되는지 확인합니다. 
문제가 지속되면 서버를 재부팅하고, 필요에 따라 하드웨어 상태도 점검합니다.
```
> <i>[참고 링크](https://netflixtechblog.com/linux-performance-analysis-in-60-000-milliseconds-accc10403c55)</i>

</details>



<details>
<summary>좀비 프로세스에 대해 설명하라</summary>

```
좀비 프로세스는 이미 종료된 프로세스이지만, 부모 프로세스가 해당 종료를 확인하지 않아서 시스템에서 여전히 남아 있는 상태를 의미합니다. 
좀비 프로세스는 시스템에 소수의 리소스를 소비하며, 일반적으로 관리가 필요하지 않습니다. 
그러나 과도한 수가 발생하면 시스템의 성능에 영향을 줄 수 있으므로, 주기적으로 청소하는 것이 좋습니다.
```
</details>



<details>
<summary>리눅스에서 가상화를 어떻게 구현할 수 있는지 설명하시오</summary>

```
리눅스에서 가상화는 주로 두 가지 방법(컨테이너 기반과 가상머신(VM) 기반)으로 이루어지지만, 때로는 이 두 가지 방법을 혼합하여 사용하기도 합니다.

- 컨테이너 기반 가상화: Docker와 같은 컨테이너 기술은 리눅스 커널을 활용하여 프로세스를 격리하는 방식으로 가상화를 구현합니다. 여러 개의 컨테이너를 호스트에서 실행하여 각각 독립적인 환경을 유지하면서 시스템 자원을 공유할 수 있습니다.
- 가상머신(VM) 기반 가상화: KVM(Kernel-based Virtual Machine)과 같은 가상화 솔루션을 사용하여 호스트 시스템 위에 게스트 운영 체제를 실행하는 방식입니다. 이 방법은 전체적인 가상화를 제공하므로 호스트와는 완전히 분리된 환경을 제공할 수 있습니다.
- 컨테이너와 가상머신의 혼합 사용: 일부 시나리오에서는 컨테이너와 가상머신을 혼합하여 사용하는 것이 유용할 수 있습니다. 예를 들어, 가상머신 내에서 여러 개의 컨테이너를 실행하여 각각의 컨테이너가 독립적인 환경을 유지하면서 VM의 장점을 활용할 수 있습니다.

이러한 방법들은 각각의 장단점을 가지고 있으며, 사용하고자 하는 시스템 요구사항과 용도에 따라 적절한 가상화 기술을 선택할 수 있습니다.
```

</details>



<details>
<summary>리눅스 서버에 원격으로 접근할 수 있는 방법과 장단점을 나열하시오.</summary>

```
리눅스 서버에 원격으로 접근하는 방법으로는 SSH, VNC, 그리고 웹 기반 터미널 도구가 있습니다. 
SSH는 보안이 우수하고 설정이 간단하지만, GUI에 접근하기 어려운 단점이 있습니다. 
VNC는 그래픽 환경에 접근할 수 있지만 보안 취약점과 설정이 복잡한 단점이 있습니다. 
웹 기반 터미널 도구는 브라우저를 통해 접근할 수 있어 편리하지만 보안 문제나 성능 저하가 발생할 수 있습니다.
```

</details>



<details>
<summary>리눅스 배포본을 비교해보시오. (Red Hat, CentOS, Oracle Linux, SUSE, Ubuntu)</summary>

```
리눅스 배포판은 서로 다른 조직이나 개발자들이 개발하고 유지보수하는 리눅스 시스템의 변형이며, 
주로 Red Hat, CentOS, Oracle Linux, SUSE, Ubuntu 등이 있습니다.

Red Hat Enterprise Linux (RHEL):
- 기업 및 기관에서 주로 사용되는 상업용 리눅스 배포판입니다.
- 안정성과 보안성이 강조되며, 엔터프라이즈 서버 환경에 적합합니다.
- 구독 기반의 서비스를 제공하며, 서버 지원과 패치 업데이트가 제공됩니다.

CentOS:
- RHEL 소스 코드를 기반으로 개발된 무료 및 오픈 소스 리눅스 배포판입니다.
- RHEL과 거의 동일한 기능과 호환성을 제공하지만, 무료로 제공됩니다.
- 개발 및 테스트 환경에서 널리 사용되며, 커뮤니티에 의해 지원됩니다.

Oracle Linux:
- 오라클에서 개발하고 유지 보수하는 엔터프라이즈급 리눅스 배포판입니다.
- RHEL과 호환되며, 오라클의 엔터프라이즈 솔루션과 통합되어 있습니다.
- 오라클 제품과의 통합 및 호환성을 강조하며, 오라클 지원 및 서비스를 제공합니다.

SUSE Linux Enterprise Server (SLES):
- SUSE사에서 개발하고 유지 보수하는 엔터프라이즈급 리눅스 배포판입니다.
- 안정성과 신뢰성이 높으며, 가상화 및 클라우드 환경에 적합합니다.
- 오픈소스와 상용 소프트웨어의 조합으로 제공되며, 다양한 서비스와 지원을 제공합니다.

Ubuntu Server:
- 개인 및 기업에서 널리 사용되는 데스크톱 및 서버용 리눅스 배포판입니다.
- 무료로 제공되는 오픈 소스 소프트웨어이며, 사용자 친화적이고 다양한 패키지를 제공합니다.
- 클라우드 및 컨테이너 환경에서 인기가 높으며, 재무적으로 경제적인 선택입니다.
```

</details>



<details>
<summary>FUSE와 파일시스템의 차이는? 성능 차이를 무시하고라도 FUSE는 쓸만한가?</summary>

```
FUSE는 "Filesystem in Userspace"의 약자로, 사용자 공간에서 파일 시스템을 개발하고 구현할 수 있는 인터페이스를 제공합니다. 따라서 사용자가 파일 시스템을 구현할 때 일반적으로 커널의 변경이 필요하지 않습니다. 
이와 달리, 일반적인 파일 시스템은 커널 영역에서 직접 작동하며, 커널 소스 코드에 직접 구현되어야 합니다.

성능 면에서는 FUSE가 일반적인 파일 시스템보다 느릴 수 있습니다. 이는 FUSE가 사용자 공간과 커널 간의 데이터 전송 및 시스템 호출을 더 많이 처리해야 하기 때문입니다. 

따라서 성능이 아닌 개발 및 유지보수의 편의성 측면에서는 FUSE가 매우 유용하지만, 고성능이 필요한 상용 환경에서는 일반적인 파일 시스템이 더 적합할 수 있습니다.
```

</details>



<details>
<summary>리눅스의 메모리 할당 방식에 대해서 설명하시오.</summary>

```
리눅스에서의 메모리 할당은 크게 두 가지 방식으로 이루어집니다.

1. 물리적인 메모리 할당: 리눅스는 물리적인 메모리를 가상 주소 공간에 할당합니다. 이는 프로그램이 실제 메모리 주소를 알 필요 없이 가상 주소를 사용하여 데이터를 저장하고 읽을 수 있게 해줍니다.
2. 가상 메모리 및 스왑 메모리 할당: 리눅스는 가상 메모리를 사용하여 물리적 메모리보다 큰 양의 데이터를 처리할 수 있습니다. 물리적 메모리가 부족한 경우에는 스왑 메모리를 사용하여 일부 데이터를 디스크에 저장하고 필요할 때 메모리로 다시 로드합니다.

이러한 메모리 할당 방식은 시스템의 유연성과 효율성을 높이며, 프로그램이 메모리를 효율적으로 활용할 수 있도록 합니다.
```

</details>



<details>
<summary>리눅스의 네임스페이스가 무엇인가? (가상화 관련/도커 컨테이너등에서 사용)</summary>

```
리눅스의 네임스페이스는 프로세스의 리소스를 격리하는 기술로, 가상화 및 컨테이너화에 중요한 역할을 합니다. 
각각의 네임스페이스는 프로세스 그룹에 대한 독립적인 가상 환경을 제공하여, 서로 영향을 주지 않고 독립적으로 동작할 수 있도록 합니다. 
이는 도커 컨테이너와 같은 가상화 기술에서 각 컨테이너가 독립적으로 실행되고 서로 영향을 주지 않도록 보장합니다. 
이를 통해 리소스의 효율적인 관리와 격리가 가능해집니다.
```

</details>



<details>
<summary>kmalloc과 vmalloc의 차이점은 무엇인가?</summary>

```
kmalloc은 커널에서 작은 크기의 메모리를 동적으로 할당하는 함수이고, vmalloc은 커널에서 큰 크기의 메모리를 할당하는 함수입니다. 
kmalloc은 주로 페이지 크기보다 작은 작업에 사용되며, 할당된 메모리는 연속된 물리적인 페이지에 매핑됩니다. 
반면에, vmalloc은 페이지 크기보다 큰 메모리를 할당하고, 할당된 메모리는 물리적인 페이지와 연속되지 않을 수 있습니다. 
```

</details>



<details>
<summary>리눅스 부트 프로세스를 최대한 자세히 설명하시오.</summary>

```
리눅스 부트 프로세스는 시스템이 부팅될 때 가장 먼저 실행되는 프로세스입니다. 
주로 init 프로세스라고도 불리며,  커널 이미지를 메모리에 로드하고 초기화하는 역할을 합니다. 
init 프로세스는 시스템의 실행 레벨을 설정하고, 필요한 시스템 리소스를 초기화하며, 시스템의 안정적인 운영을 위해 중요한 역할을 합니다. 
일반적으로 시스템이 부팅되면 init 프로세스가 시작되고, 그 후에 사용자 공간 및 시스템 서비스들이 순차적으로 시작됩니다.
```

</details>



<details>
<summary>대량의 서버를 사내에서 구입했다고 가정해보자. Ubuntu와 CentOS 중 무엇을 선택하겠는가?</summary>

```
대량의 서버를 구입할 때 Ubuntu와 CentOS 중에서 선택할 때에는 사용 목적과 운영 환경을 고려해야 합니다. 
Ubuntu는 사용하기 쉽고 빠른 업데이트 주기를 가지며 개발 및 데스크톱 환경에서 많이 사용됩니다. 
반면 CentOS는 안정성과 보안에 초점을 맞춘 레드햇 엔터프라이즈 리눅스의 무료 버전으로서 엔터프라이즈 환경에서의 우수한 성능과 안정성을 제공합니다. 
기업의 운영 환경과 요구 사항에 따라 적합한 배포판을 선택하는 것이 중요합니다.
```

</details>



<details>
<summary>busybox가 무엇인가? 왜 사용하는가</summary>

```
BusyBox는 리눅스 기반 시스템에서 경량의 다목적 유틸리티 프로그램으로 사용됩니다. 
이는 여러 유틸리티를 하나의 실행 파일로 통합하여 시스템 자원을 절약하고 기본적인 작업을 처리하는 데 도움을 줍니다. 
주로 임베디드 시스템이나 리소스가 제한된 환경에서 사용되며, 작고 가벼우면서도 다양한 유틸리티를 제공하여 시스템을 관리할 수 있습니다.
```

</details>



<details>
<summary>OOM 정의와 발생 원인과 해결 방법</summary>

```
OOM(Out Of Memory)은 시스템이 사용 가능한 메모리를 모두 소진한 상태를 나타냅니다. 
이는 주로 프로세스가 너무 많은 메모리를 요청하거나 메모리 누수로 인해 사용 가능한 메모리가 점점 감소하는 경우 발생합니다. 

OOM을 해결하기 위한 방법에는 메모리를 효율적으로 사용하는 프로그램을 개발하여 메모리 누수를 방지하는 것입니다.
또한, 스왑 공간을 늘리거나 추가 메모리를 설치하여 메모리 용량을 늘리거나, 
OOM이 발생했을 때 시스템을 다시 시작하여 메모리를 초기화하는 방법이 있습니다. 
마지막으로, OOM Killer라는 커널 기능을 사용하여 메모리를 가장 많이 사용하는 프로세스를 강제로 종료시키는 방법도 있습니다.
```

</details>

