# [ week2 ] 운영체제

<details> 
<summary>운영체제란 무엇인가?</summary>

```
운영체제는 컴퓨터 시스템의 핵심 소프트웨어로, 하드웨어 자원을 효율적으로 관리하고 응용 프로그램이 원활하게 동작할 수 있도록 지원하는 프로그램입니다. 
프로세스 관리, 메모리 관리, 파일 시스템 관리, 입출력 관리 등 다양한 기능을 수행하여 컴퓨터 시스템의 안정성과 성능을 유지합니다. 
기본적으로 사용자와 하드웨어 간의 중간 매개체 역할을 하며, 운영체제 없이는 컴퓨터가 작동할 수 없습니다.
```

</details>



<details>
<summary>프로세스와 스레드의 차이는 무엇인가요?</summary>

```
프로세스와 스레드는 둘 다 실행 중인 프로그램의 실행 단위를 나타냅니다. 
하지만 가장 큰 차이점은 프로세스는 독립적인 메모리 공간을 가지고 있는 반면, 스레드는 프로세스 내에서 공유하는 메모리 공간을 사용합니다. 이는 프로세스 간 통신이 비교적 느리고 복잡한 반면, 스레드는 간단하고 빠른 데이터 공유가 가능하다는 것을 의미합니다. 
또한, 프로세스는 운영체제로부터 독립적인 자원을 할당받으며, 각 프로세스는 독립적으로 실행되어 하나의 프로세스가 비정상적으로 종료되어도 다른 프로세스에 영향을 주지 않습니다. 반면에 스레드는 같은 프로세스 내에서 실행되기 때문에, 하나의 스레드가 문제가 발생하면 같은 프로세스 내의 다른 스레드들에게 영향을 줄 수 있습니다. 
결국, 프로세스와 스레드는 실행 단위의 차이뿐만 아니라 메모리 공간 및 자원 관리에서도 차이점이 존재합니다.
```

</details>



<details>
<summary>멀티 프로세스와 멀티 스레드의 차이는 무엇인가요?</summary>

```
멀티 프로세스와 멀티 스레드는 둘 다 병행 처리를 위한 기술입니다. 
하지만 가장 큰 차이점은 멀티 프로세스는 각각의 프로세스가 독립된 작업 공간을 가지고 실행되는 반면, 멀티 스레드는 하나의 프로세스 내에서 여러 개의 작은 작업이 동시에 실행되고, 프로세스 내의 자원을 공유한다는 점입니다. 
또한, 멀티 프로세스는 각각의 프로세스가 독립적으로 실행되기 때문에 더 많은 자원을 사용할 수 있는 반면, 멀티 스레드를 사용하면 작업 간 통신이 간단하고 자원 사용이 효율적입니다. 
결국, 각각의 상황에 따라 적합한 기술을 선택하는 게 중요합니다.
```

</details>



<details>
<summary>멀티 프로세스로 처리 가능한 걸 굳이 멀티 스레드로 하는 이유는?</summary>

```
멀티 프로세스보다 멀티 스레드를 선택하는 이유는 멀티 프로세스보다 자원 공유와 성능 측면에서 유리하기 때문입니다. 
멀티 스레드를 사용하면 하나의 프로세스 내에서 작업을 동시에 처리할 수 있습니다. 이는 자원 공유를 더 쉽게 만들어주고, CPU를 최대한 활용하여 작업을 빠르게 완료할 수 있게 도와줍니다. 
또한, 사용자에게 빠른 응답을 제공하는 데도 도움이 됩니다. 멀티 스레드는 작업을 여러 개의 작은 조각으로 나누어 각각을 병렬로 실행함으로써 작업을 효율적으로 처리할 수 있습니다. 
```

</details>



<details>

<summary>동기와 비동기의 차이?</summary>

```
동기는 프로그램에서 작업을 순차적으로 처리하는 방식입니다. 이는 한 작업이 끝나야 다음 작업을 시작할 수 있어 작업들 간 의존성이 높은 방식입니다.
반면에 비동기는 프로그램에서 작업을 동시에 병렬적으로 처리하는 방식입니다. 한 작업의 결과를 기다리지 않고 다음 작업을 진행하기 때문에 작업들 간 의존성이 낮은 방식입니다. 
```

</details>



<details>
<summary>멀티 스레드 환경에서의 주의 사항?</summary>

```
먼저, 경쟁 상태나 데드락과 같은 문제를 피하기 위해 상호 배제와 락을 사용해야 합니다. 
또한, 스레드 안전성을 유지하기 위해 공유 자원에 대한 접근을 조절하고 데이터 공유를 관리해야 합니다.
마지막으로, 메모리 일관성 문제를 방지하기 위해 메모리 모델과 일관성을 이해하고, 필요한 경우 쓰기 작업이 완전히 끝날 때까지 다른 스레드가 해당 값을 읽지 못하도록 보장해야 합니다.
```

```
멀티 스레드 환경에서 주의해야 할 점은 다음과 같습니다:

1. 경쟁 상태(Race Condition): 여러 스레드가 동시에 같은 자원에 접근하거나 수정할 때 예상치 못한 결과가 발생할 수 있습니다. 이를 방지하기 위해 스레드 간의 접근을 조절하는 동기화 메커니즘이 필요합니다.

2. 데드락(Deadlock): 두 개 이상의 스레드가 서로 상대방의 작업이 끝나기를 기다리며 무한히 대기하는 상황을 말합니다. 데드락을 피하기 위해 스레드가 자원을 점유한 상태에서 다른 자원을 요청할 때 순서를 지키거나 타임아웃 등의 방법을 사용해야 합니다.

3. 스레드 안전성(Thread Safety): 여러 스레드가 동시에 공유 자원에 접근할 때 발생할 수 있는 문제를 해결해야 합니다. 즉, 스레드 간의 충돌을 방지하고 데이터 일관성을 유지하기 위해 적절한 동기화 기법을 사용해야 합니다.

4. 메모리 일관성(Memory Consistency): 멀티 스레드 환경에서는 메모리 일관성 문제가 발생할 수 있습니다. 따라서 메모리 모델을 이해하고, 쓰기 작업이 완전히 끝날 때까지 다른 스레드가 해당 값을 읽지 못하도록 보장해야 합니다.

이러한 주의 사항들을 고려하여 멀티 스레드 환경에서 안전하고 효율적인 프로그램을 개발할 수 있습니다.
```

</details>



<details>
<summary>교착상태(DeadLock)가 무엇이며, 4가지 조건은?</summary>

```
교착상태(Deadlock)는 멀티 스레드나 프로세스 간의 상황으로, 각각의 스레드나 프로세스가 서로가 가진 자원을 기다리면서 무한히 대기하는 상황을 말합니다. 
교착상태는 상호 배제, 보유 대기, 비선점, 순환 대기라는 4가지 조건이 모두 충족될 때 발생합니다. 

1. 상호 배제(Mutual Exclusion): 최소한 하나의 자원이 동시에 하나의 프로세스나 스레드에 의해서만 사용될 수 있어야 합니다.
2. 보유 대기(Hold and Wait): 적어도 하나의 자원을 보유한 상태에서 다른 자원을 기다리고 있어야 합니다.
3. 비선점(No Preemption): 다른 프로세스나 스레드에 의해 보유 중인 자원을 강제로 빼앗을 수 없어야 합니다. 자원은 해당 프로세스나 스레드가 직접 반납할 때까지 보유됩니다.
4. 순환 대기(Circular Wait): 각 프로세스나 스레드의 자원 요청이 순환적으로 연결되어 있어야 합니다. 즉, 프로세스나 스레드 간의 자원 요청이 사이클을 형성해야 합니다.

교착상태를 방지하기 위해서는 4가지 조건들 중 하나라도 없애거나 교착상태를 미연에 방지할 수 있는 방법을 사용해야 합니다.
```

</details>



<details>
<summary>가상 메모리란?</summary>

```
가상 메모리는 운영체제에서 사용되는 메모리 관리 기술입니다. 이 기술은 실제로는 물리적인 메모리(RAM)보다 큰 용량의 메모리 공간을 프로세스에 제공합니다. 이를 통해 여러 프로그램이 동시에 실행될 때도 충분한 메모리를 할당할 수 있습니다. 
가상 메모리는 프로세스의 일부를 실제 메모리에 적재하고, 필요할 때에만 필요한 부분을 디스크의 가상 메모리 파일에서 가져와서 사용합니다. 이러한 방식으로 가상 메모리는 사용자에게는 무한한 메모리 공간을 제공하는 것처럼 보이지만, 실제로는 물리적인 메모리와 디스크의 조합으로 구현됩니다. 
가상 메모리를 사용하면 메모리 관리가 효율적으로 이루어지며, 프로그램의 실행 속도와 시스템의 성능을 향상시킬 수 있습니다.
```

</details>



<details>
<summary>외부 단편화와 내부 단편화란?</summary>

```
외부 단편화는 프로세스들이 메모리에 할당될 때, 사용하지 못한 작은 메모리 조각들로 인해 메모리 공간이 낭비되는 현상을 말합니다. 이는 프로세스들이 메모리에 할당되고 제거될 때 반복적으로 발생할 수 있습니다.

반면 내부 단편화는 프로세스가 할당받은 메모리 공간이 프로세스가 요구한 메모리 양보다 큰 경우 발생합니다. 이는 프로세스가 실제로 사용하지 않는 메모리 공간을 낭비하는 현상으로, 내부 단편화는 주로 고정 크기의 메모리 할당 방식에서 발생합니다.
```

</details>




<details>
<summary>페이징과 세그먼테이션이란?</summary>

```
페이징과 세그먼테이션은 운영체제에서 메모리 관리를 위한 기법입니다.
페이징은 메모리를 고정된 크기의 작은 블록으로 분할하는 방식입니다. 이 작은 블록을 페이지라고 부르며, 프로세스도 이와 같은 크기의 페이지로 분할됩니다. 페이징은 외부 단편화를 해결할 수 있지만, 내부 단편화 문제를 가질 수 있습니다.
세그먼테이션은 메모리를 논리적인 블록인 세그먼트로 분할하는 방식입니다. 각 세그먼트는 크기가 가변적이며, 물리적인 메모리에 연속적으로 할당되지 않을 수 있습니다. 세그먼테이션은 외부 단편화를 해결할 수 있지만, 내부 단편화 문제를 가질 수 있습니다.
```

</details>



<details>
<summary>비선점형(Non-preemptive) 스케줄링</summary>

```
스케줄링 알고리즘은 CPU 스케줄러가 준비 큐에 있는 프로세스 중 어떤 프로세스를 실행시킬지 결정하는데 사용하며, 이는 비선점형과 선점형으로 나뉩니다.
```

```
비선점형(Non-preemptive) 스케줄링은 현재 CPU를 사용 중인 프로세스가 있을 때 다른 프로세스가 CPU를 강제로 가져갈 수 없는 방식입니다.
비선점형 스케줄링은 간단하고 구현하기 쉽지만, 긴 프로세스가 CPU를 점유하는 경우 다른 프로세스들이 오랜 시간동안 대기해야 하는 문제가 있습니다.  
```

</details>

<details>
<summary>선점형(Non-preemptive) 스케줄링</summary>

```
선점형(Preemptive) 스케줄링은 현재 CPU를 사용 중인 프로세스가 있더라도 우선순위가 높은 다른 프로세스가 CPU를 강제로 가져갈 수 있는 방식입니다. 이때 CPU를 뺏어가는 과정을 문맥 전환(Context Switching)이라고 합니다.
선점형 스케줄링은 우선순위가 높은 작업이나 긴급한 작업을 빠르게 처리할 수 있지만, 문맥 전환이라는 작업이 추가로 발생하여 오버헤드가 발생할 수 있습니다.
```

</details>

<details>
<summary>인터럽트란 무엇인가요?</summary>

```
인터럽트는 컴퓨터 시스템에서 발생하는 예기치 않은 이벤트를 의미합니다. 이러한 이벤트는 CPU가 현재 수행 중인 작업을 중단하고, 해당 이벤트에 대응하여 특정한 동작을 수행하도록 합니다.
```

```
일반적으로 인터럽트는 하드웨어나 소프트웨어에서 발생합니다. 하드웨어 인터럽트는 주변장치(ex. 키보드, 마우스, 디스크)에서 발생할 수 있고, 소프트웨어 인터럽트는 프로그램 실행 도중 명령어의 실행이나 예외 상황 발생 시 발생할 수 있습니다.
```

</details>



<details>
<summary>운영체제한테 CPU가 넘어가는 경우는 언제인가?</summary>

```
인터럽트가 발생하거나, 시스템 호출이 발생하거나, 프로세스가 종료되거나, 타임 슬라이스가 종료되는 경우 
운영체제한테 CPU가 넘어갑니다.
```

```
운영체제한테 CPU가 넘어가는 경우는 다음과 같습니다:

1. 인터럽트 발생: 하드웨어 인터럽트(ex. 입출력 요청)나 소프트웨어 인터럽트(ex. 프로그램이 오류를 발생시킴)와 같은 예기치 않은 이벤트가 발생할 때 CPU는 해당 인터럽트를 처리하기 위해 현재 실행 중인 프로세스를 일시 중단하고, 인터럽트 서비스 루틴을 실행합니다.

2. 시스템 호출: 프로세스가 운영체제에게 특정한 서비스를 요청할 때(ex. 파일을 열거나 닫을 때), 운영체제는 CPU를 해당 서비스를 처리하는 데 사용합니다.

3. 프로세스 종료: 현재 실행 중인 프로세스가 종료되거나 대기 상태로 들어갈 때, CPU는 다음에 실행될 프로세스에게 넘어갑니다.

4. 타임 슬라이스 종료: 선점형 스케줄링에서는 CPU가 현재 프로세스를 실행하는 동안 일정한 시간(타임 슬라이스)이 지나면 CPU가 다른 프로세스로 넘어갑니다.

이러한 경우들을 통해 운영체제는 시스템 리소스를 효율적으로 관리하고, 다양한 작업을 동시에 처리할 수 있습니다.
```

</details>



<details>
<summary>인터럽트 처리중에 또다른 인터럽트가 발생하는 경우는 어떻게 되는가?</summary>

```
인터럽트 처리 중에 또다른 인터럽트가 발생하면, 현재 처리 중인 인터럽트의 실행이 중단되고 새로 발생한 인터럽트를 우선 처리합니다. 이를 우선순위 판별이라고 합니다. 
운영체제는 높은 우선순위를 가진 인터럽트를 먼저 처리하고, 처리가 완료되면 낮은 우선순위의 인터럽트를 다시 처리합니다. 
이렇게 함으로써 시스템은 중요한 이벤트에 우선순위를 부여하여 신속하게 대응할 수 있습니다.
```

</details>



<details>
<summary>PCB란 무엇인가요?</summary>

```
PCB(Process Control Block)는 프로세스를 제어하기 위해 프로세스 정보를 저장하는 자료구조입니다. 
PCB에 저장되는 프로세스 정보에는 프로세스의 현재 상태, 프로세스를 나타내는 고유의 PID, 부모 프로세스의 PID, 자식 프로세스의 PID, 다음 실행할 명령어의 주소인 PC(Program Counter) 등이 있습니다.
```

</details>



<details>
<summary>PCB는 왜 필요한가요?</summary>

```
PCB는 운영체제가 각 프로세스를 식별하고 관리하는 데 사용하는 자료구조로, 각 프로세스에 대한 중요한 정보를 담고 있습니다.
PCB는 프로세스의 상태, 레지스터 값, 스케줄링 정보 등을 저장하며, 문맥 전환이 발생할 때 이 정보를 사용하여 프로세스 간의 전환을 가능하게 합니다. 
또한, PCB는 운영체제가 프로세스의 우선순위와 자원 사용을 관리하는 데 필요한 정보도 제공합니다. 
따라서 PCB는 운영체제가 프로세스를 효율적으로 관리하고 자원을 효율적으로 할당하는 데 필수적입니다.
```

```
PCB는 여러 이유로 필요합니다:

1. 프로세스 관리: PCB는 운영체제가 프로세스를 식별하고 관리하는 데 필요한 중요한 정보를 포함하고 있습니다. 각 프로세스에 대한 정보를 저장하고 추적함으로써 운영체제는 프로세스를 효율적으로 관리할 수 있습니다.

2. 문맥 전환: PCB에는 프로세스의 상태와 레지스터 값 등의 정보가 저장되어 있습니다. 이 정보를 사용하여 운영체제는 프로세스 간의 문맥 전환이 발생할 때 현재 실행 중인 프로세스의 상태를 저장하고 다음에 실행할 프로세스의 상태를 복원할 수 있습니다.

3. 스케줄링: PCB에는 프로세스의 우선순위 및 스케줄링 정보도 포함됩니다. 이를 통해 운영체제는 프로세스의 실행 순서를 결정하고 CPU 자원을 효율적으로 할당할 수 있습니다.

4. 자원 관리: PCB는 프로세스가 사용 중인 자원에 대한 정보도 포함합니다. 이를 통해 운영체제는 프로세스가 요구하는 자원을 추적하고 관리할 수 있습니다.

따라서 PCB는 운영체제가 프로세스를 효율적으로 관리하고 자원을 효율적으로 할당하는 데 필수적입니다.
```

</details>



<details>
<summary>Context Swiching이란 무엇인가요?</summary>

```
컨텍스트 스위칭(Context Switching, 문맥 전환)은 현재 CPU가 실행 중인 프로세스에서 다른 프로세스로 전환되는 과정을 의미합니다. 이는 다수의 프로세스가 동시에 실행되는 운영체제에서 중요한 작업입니다. 
컨텍스트 스위칭은 현재 실행 중인 프로세스의 상태를 저장하고 다음에 실행할 프로세스의 상태를 복원하는 과정을 포함합니다. 
컨텍스트 스위칭은 시스템이 다중 프로그래밍 및 멀티태스킹을 지원하고, 여러 프로세스가 공유 자원을 안전하게 사용할 수 있도록 합니다.
```

</details>



<details>
<summary>사용자 수준 스레드 vs 커널 수준 스레드</summary>

```
사용자 수준 스레드와 커널 수준 스레드는 스레드를 생성하고 관리하는 방식에 차이가 있습니다.
사용자 수준 스레드는 스레드 관리를 운영체제 대신 사용자 프로그램에서 수행하는 방식입니다. 스레드 생성, 스케줄링, 동기화 등의 작업은 사용자 프로그램 내부에서 이루어지며, 운영체제는 해당 스레드를 단순히 하나의 프로세스로만 인식합니다. 
이에 반해, 커널 수준 스레드는 스레드 관리를 운영체제 커널에서 수행합니다. 스레드 생성, 스케줄링, 동기화 등의 작업은 운영체제의 커널 내부에서 이루어지므로 보다 효율적이고 안전한 스레드 관리가 가능합니다. 
따라서 사용자 수준 스레드는 가벼운 스레드 생성과 관리를 제공하고, 커널 수준 스레드는 보다 강력한 스레드 관리를 제공합니다. 선택은 프로그램의 요구사항과 성능 요소에 따라 다를 수 있습니다.
```

</details>



<details> 
<summary>뮤텍스, 세마포어가 뭔지, 차이점은?</summary>

```
뮤텍스(Mutex)와 세마포어(Semaphore)는 동시에 여러 스레드가 공유된 자원에 접근하는 것을 조절하는 동기화 도구입니다.

뮤텍스는 하나의 스레드만이 공유 자원에 접근할 수 있도록 하는 동기화 도구입니다. 뮤텍스를 소유하고 있는 스레드만이 자원에 접근할 수 있고, 다른 스레드들은 뮤텍스가 잠긴 동안 대기합니다. 이는 뮤텍스가 이진 상태(잠금 또는 잠금 해제)를 가지고 있기 때문입니다.

세마포어는 여러 스레드가 공유 자원에 접근할 수 있는 허용 가능한 수를 제어하는 카운팅 기반의 동기화 도구입니다. 세마포어는 wait()과 signal() 연산을 통해 자원의 사용과 반환을 조절합니다. wait() 연산은 카운터를 감소시키고, 카운터가 0인 경우 스레드를 대기시킵니다. 반대로 signal() 연산은 카운터를 증가시키고, 대기 중인 스레드를 깨웁니다.

이 둘의 주요 차이는 뮤텍스는 단일 스레드가 자원에 접근하는 것을 보장하는 데 사용되고, 세마포어는 여러 스레드가 동시에 자원에 접근하는 것을 허용하는데 사용됩니다. 따라서 세마포어는 더 복잡한 동기화 문제를 해결하는 데 유용합니다.
```

</details>



<details>
<summary>프로세스의 스택, 데이터, 코드, 힙에 대해 설명해주세요.</summary>

```
프로세스는 메모리를 사용하여 실행되며, 일반적으로 네 가지 주요 영역으로 구성됩니다.

1. 코드(Code): 코드 영역은 프로그램의 명령어들이 저장되는 곳입니다. 여기에는 프로그래머가 작성한 소스 코드가 컴파일되어 생성된 실행 파일의 명령어들이 포함됩니다.

2. 데이터(Data): 데이터 영역은 초기화된 전역 변수와 정적 변수를 저장합니다. 이 공간은 프로그램이 시작될 때 초기값으로 초기화됩니다.

3. 스택(Stack): 스택 영역은 함수 호출과 관련된 정보를 저장합니다. 각 함수 호출 시 매개변수, 지역 변수, 함수의 반환 주소 등이 스택에 저장되며, 함수가 반환되면 이 정보가 제거됩니다.

4. 힙(Heap): 힙 영역은 동적으로 할당된 메모리를 관리 및 저장하는 곳입니다. 프로그램 실행 중에 동적으로 할당되며, 사용자가 명시적으로 해제하기 전까지 유지됩니다. 힙은 프로그램 실행 도중 크기가 변경되는 데이터를 저장하는 데 사용됩니다.

이렇게 각 영역은 프로그램이 실행되는 동안 메모리에서 서로 다른 목적으로 사용되며, 프로그램의 실행과 데이터 저장을 지원합니다.
```

</details>

<details>
<summary>4 CPU 환경에서 4개의 스레드가 실행된다고 가정해보자. 어떤 문제가 발생할 수 있겠는가?</summary>

```
4 CPU 환경에서 4개의 스레드가 실행될 때 발생할 수 있는 문제에는 자원 경합, 스레드 우선순위 설정 문제, 외부 자원 대기 시간 문제 등이 있습니다.

- 자원 경합(Race Condition): 여러 스레드가 공유된 자원에 동시에 접근할 때 발생하는 문제로, 예상치 못한 결과를 초래할 수 있습니다. 예를 들어, 두 개의 스레드가 동시에 같은 변수를 수정하는 경우 변수의 최종 값이 예상과 다를 수 있습니다.
- 스레드 우선순위 설정 문제: 잘못된 스레드 간의 우선순위 설정이 잘못되면 특정 스레드가 지나치게 많은 CPU 시간을 소비하여 다른 스레드의 실행을 방해할 수 있습니다.
- 외부 자원 대기 시간 문제: 네트워크 통신이나 파일 입출력과 같은 외부 자원에 대한 대기 시간이 발생할 경우 CPU가 대기 상태에 머무를 수 있습니다.

이러한 문제들은 적절한 스레드 관리 및 자원 관리 정책을 통해 해결할 수 있습니다. 예를 들어, 상호 배제(mutex)를 사용하여 공유된 자원에 대한 접근을 동기화하거나, 스레드 우선순위를 설정하여 CPU 할당을 조절함으로써 해결할 수 있습니다.
```

</details>

